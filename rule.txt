#package roles
1. akta folder e aktar beshi package thakte parbe nah.
2. package er nam mela kichui hoite pare but easiest way hoilo folder er nam rei package er nam hishabe diya dea.
3. funtion must be exported(fiest letter is capital) to call it from another package
4. unexported function( first letter is small) from another package


##for run a code, commands are.
1. go run "name(x,y,z)"
2. go run .


## basic rules
1. All file in go must have/need a package.
2. the package of main go file will be main
3. fmt => format 
4. format consist many library fuctions so we must import it 


##variable 
1. variable declaration style like this a:= 10 (local variable)
2. global varibale diclaration method is like a=10
3. function er vitor e (local variable) amra veriable type use korteo pari nao pari, i mean ' := ' ere use korle data type dileo hobe na dileo hobe
  but globally jehetu amra ' := ' ere use korte parmu na so must be amder k data type boila dite hobe.
4. variable declaration aktu awkword compare to other
-->var age int = 25
--> var pi float64 = 3.1415
--> var greeting string = "Hello"
--> var isGoFun bool = true
--> 
-->  

5. struct akta important data types:
    declaration process of struct 
    type Person struct {
    Name string
    Age  int
}

## conditional is like C

## function gulay nam age variable type pore.
    others jinish pati C er motoi
    return type boila dite hoy like this " func add(n1 int, n2 int) int {}

##scope
 means accessing any variable from any part of the code( access korte parle scope ache otherwise nai) 


##function
 1. I already discuss in the package roles sections
 2. Types of function in go--->
  a. init function(no input/output needed, computer call it by own) 
     execution order: global--> init() -> main() -> other functions
  b. standard or named named function(have a name)
  c. anonymous function( js e declare kore rekhe dea jay)
     but go te declare kore rekhe dea jay na.
     immediatly invoke function expression(IIFE) kore eitare
  

##Function expression
 1. variable er moddhe akta value assign korle oita hocche variable expression
 2. jodi akta veriable er moddhe pura akta function assign kora hoy tahole oita function expression
  example:
  /* add:= func(a int, b int){
    c:= a+b
    fmt.Println(c)
  }


##Others function type:
 1.First order function(
    -->A first-order function is a normal function that does not take other functions as arguments and does not return a function.
    -->It just takes simple inputs (numbers, strings, etc.) and returns simple outputs.
    )
 2.Higher order function(
    -->Also called first class function[variable er moddhe j kono dhoroner value assign kora jay oitare bole first class citizen,
        amra go te variable er moddhe function assign korte pari tai j function e pass kora hoy oitare boli first class functions]
    -->A higher-order function is a function that can take another function[ere bole call back function] as an argument or return a function
    -->This makes code more flexible and allows things like callbacks, functional patterns, etc
  )


##internal memeory["code segmet", "data segment", "stack", "heap"]
 1. variable(global) gula thake data segment e
 2. method/function gula thake code segment e
 3. all method calls[execution] in stack and the speace one method takes for running it's call stack frame[different for each fuction]


##Closure
 1. a closure is a function value that captures variables from its surrounding scope
 2. Even after the outer function has finished executing, the inner function (closure) can still access and modify those variables.
 3. amne function e akbar execution sesh e variable mara jay but anonymous function(or return function) inside another function define korle go oitare
    totokkhon bachay rakhe jotokkhon closure in use theke(main thake call dey)
 4.Escape to heap 
   Normally, when outer() finishes, its stack frame disappears, and money would be destroyed. 
   But since show captures money, Go’s compiler/runtime performs escape analysis and moves money to the heap, so it outlives outer().
   Closure object created
   the closure (show) is represented internally as a pair:
   A function pointer → the compiled code of show
   An environment pointer → a hidden struct on the heap holding money   
   like this code:
   
   f = {
    fn_ptr: &show_code,
    env_ptr: &{ money = 100 }
   }

##slice
 Internally, a slice has three parts:
  2.Pointer → points to the underlying array
  3.Length → number of elements currently in the slice
  4.Capacity → maximum size it can grow before needing a new array
 There are some ways to delaring slice like-
  1.Literal(etate mainly array er motoi declare korbo but kahini hoilo array te jemon size mention kore dei oita eikhane korbo nah)
    ex: numbers := []int{1, 2, 3, 4, 5}
  2.From an array
    ex: arr := [5]int{10, 20, 30, 40, 50}
    slice := arr[1:4]    // elements at index 1,2,3
  3.Using make
    ex: s := make([]int, 3, 5) // length 3, capacity 5
  4.Slice from slice
    1.jokhon slice1 thake slice2 banabo tokhon slice1 e dakhbo koto number index theke suru hoise r koto te sesh(eta length), r jeita 
      first(slice2 te) oi value(arrray te) thake array er last element porjonto hoile capacity
    ex:
    arr := []int{10, 20, 30, 40, 50}
    s1 := arr[1:4]   // [20 30 40], len=3 cap=4
    s2 := s1[1:3]    // slice from slice → [30 40], len=2 cap=3
